Project Goal: 
Design and Implement a complete enterprise Load Balancer Product named Loadara. The product consists of an API Backend and Web UI and is built around the open source load balancers, HAProxy and Keepalived, which will provide the core load balancing functionality & failover capabilities. The Loadara API should utilize the HaProxy dataplane api to facilitate creating & validating the live HAProxy configuration and interacting with the HAProxy runtime API, metrics, and other functionality. Keepalived configurations will also need to be managed by the backend API


The API should be designed with the openapi spec & full documentation. It should be modular & extensible, allowing for easy addition of new features and functionality in the future. Loadara's backend API should be secure, with authentication, authorization, and role-based access control mechanisms and allow the user to configure & use API tokens for interacting with the API from scripts, or other automation tools. The API should provide all functionality for the frontend web interface to manage all aspects of the Loadara load balancer and Haproxy and Keepalived load balancer configurations.

The Loadara API should store all configurations & their options in a Postgresql Database:

host: localhost
port: 5432
user: loadara
password: loadara
name: loadara

Loadara's web interface should have a professional, clean design made up of colors such as white, or gray background with accents of black, and blue. It should be built using a modern JavaScript framework such as React & should be designed to be responsive and user-friendly. All of the load balancer resources includingvirtual servers, pools, servers, monitors, traffic profiles, certificates, ACLs, and other configurations should be stored in the database as independent records that can be referenced by the other resources to build load balancing configurations. For example, a user can create several virtual servers that all reference the same backend pool, or the same health monitor, or the same certificate, or the same ACLs, etc. All of the load balancer resources should be reusable and referenced by multiple virtual servers, or pools. None should be designed as a one to one relationship.

The web interface should provide a dashboard tab that displays the status & current performance of the load balancer, including 
information about the health, number of connections, or connection rates of the virtual servers, pools, and backend servers. This information can be pulled from the Haproxy Stats / Metrics endpoint which should be accessible utilizing the Haproxy dataplaneapi. The haproxy dataplaneapi provides the Haproxy configuration generation & validation, runtime api, and statistics endpoint. 

The web interface should have tabs or pages that will interact with each of the api endpoints to view, create, update, or delete load balancer resources such as virtual servers, pools, servers, monitors, traffic profiles, certificates, acls, traffic tables, traffic maps, cluster settings, system settings, users, roles, groups, and other resources. It should also have a log viewer page that allows the user to view relevant logs generated by the Loadara API, Haproxy, or Keepalived. 

The web interface should also provide a user management interface and RBAC (Role Based Access Control) functionality for managing users, groups, and roles, and permissions for the Loadara API . The web interface should also provide a system settings page that allows users to configure the Loadara system, including hostname, networking, database connection settings, logging settings, specify haproxy & keepalived configuration paths, and other relevant settings. There should also be a cluster management settings for configuring the cluster settings, including adding cluster nodes, setting primary or standby nodes, and other relevant clustering settings. 

The web interface should also provide a complete documentation and help page that provides information about how to use the Loadara API and web interface, including configuration documentation, examples, and other relevant information. 

In addition to the above, there should be an API backend for managing new and existing HAProxy ACLs, Maps, and Stick Tables. In the Loadara product 
Haproxy Stick-Tables are called Traffic Tables and Haproxy Maps are called Traffic maps. The Loadara API should 
provide endpoints for creating, updating, and deleting ACLs, Maps, and Stick Tables. The ACL page will be called the ACL Rules Wizard and will be able to help the end user build or update ACL rules using easy to use drop down selections, and fields to select fetchers, converters, operators, and actions or their required parameters. The ACL Rules Builder will be an particularily special feature on the web interface as it will provide an easy to use interface for developing complex ACLs that utilize the many ACL options available in Haproxy, including the hundreds of fetchers, converters,operators, actions, and other options. The ACLs also can reference stick-tables and maps as part of their creation, and the ACL Rules Wizard will need to support both in addition to the other ACL options. ACLs can be referenced by virtual servers, or pools and will only be generated in the Haproxy configuration when referenced in either of these types of resources.

We should also provide a page for a code/script builder that will allow users to write custom haproxy configurations, or lua scripts that can be referenced in the frontend virtual servers or backend pools. Again, these are only generated when referenced by a virtual server, or pool. 

HaProxy Configurations:
Haproxy configurations are broken up into a few sections: Global, Defaults, Frontends, Backends, and Peers. It's very important to note that configurations should only be generated, validated, and applied once a complete virtual server frontend, a pool backend, or any configurations that apply to the global, defaults, or peers sections. For example, we can create multiple monitors, profiles, Traffic Tables (stick-tables), or other items, however we should not generate any haproxy configuration for these items until they are referenced by a virtual server, or pool. 

Every time the user creates or updates a virtual server, pool, or any other configuration that applies to the global, defaults, or peers sections, the Loadara API should update and validate the Haproxy and Keepalived configuration files using either the Haproxy dataplaneapi for haproxy configurations, or for Keepalived we should generate the configuration files directly & validate them prior to reloading the Haproxy & Keepalived services i.e (sudo systemctl reload haproxy, sudo systemctl reload keepalived)

The Loadara API Backend should also manage clustered and non-clustered configurations of Haproxy and Keepalived. There should be options for setting 
up clustered configurations, including the ability to set up multiple nodes. The Loadara API should provide an endpoint and process to synchronize the data in the database to the other nodes in the cluster. This will ensure that all nodes in the cluster have the same configuration and can work together to provide highly available load balancing capabilities. Keepalived will be used to manage the virtual IP addresses and provide failover capabilities. All virtual server IPs, along with the Loadara virtual IP for the API and web interface should be managed in the Keepalived configuration as one of the virtual ip addresses. This is needed so the virtual ip adress is usable by Haproxy to load balance traffic. The primary Loadara node will be responsible for sending updates to the other nodes in the cluster to ensure configurations are synched. When clustering is enabled, Loadara should set up a "peers section" in the Haproxy configuration.

There should also be an option for UDP based virtual servers and backends, however UDP load balancing is not supported in HAProxy so UDP based virtual server frontends and backends must be configured using keepalived and defined it's virtual server configuration. Any backends that select UDP for their mode will be defined/configured in Keepalived rather than HaProxy.

Please reference the HAPROXY, and KeepAlived documentation for all of the configuration options available for each of the load balancer resources:

HAProxy Configuration Manual: https://www.haproxy.com/documentation/haproxy-configuration-manual/latest
Keepalived Configuration Manual: https://www.keepalived.org/manpage.html
HAProxy Dataplane API Reference Manual: https://www.haproxy.com/documentation/dataplaneapi/community/?v=v3

Local HAProxy Dataplane API: http://admin:admin@http://192.168.12.228:5555/v3/docs

Design, implementation and Test Instructions: We should build the basic load balancing functionality first such as basic CRUD operations for virtual servers, pools, servers, monitors, acls, certificates, then add the clustering and other features such as acl rules wizard, traffic tables, maps, scripts, etc. after the basic load balancing functionality is complete. We should be sure to keep these in mind though when building out the basic functionality first. We should build and test each component as we go along to ensure everything is working right the first time, rather than trying to create the whole product then test & troubleshoot all of the issues later.

When you creating the code please do not use mock data, or example data. Additionally, never implement work-arounds, hacks, or bypasses when you run into any issues. I want you to implement all options as described here using real data whenever possible and ensure the code is complete and ready to deploy into a production environment. Completing all of the requirements is important. Please do not leave out any of the requirements or features. The Loadara API should be designed to be modular and extensible, allowing for easy addition of new features and functionality in the future. The API should be designed to be secure, with authentication, authorization, and role-based access control mechanisms in place to protect sensitive data and prevent unauthorized access. The API should also be designed to be scalable, allowing for easy addition of new nodes to the 
cluster as needed. The API should also be designed to be performant, with low latency and high throughput, allowing for fast response times and 
efficient use of resources.

If you are unsure how to proceed, then stop and ask me for clarification. I will be happy to provide you with more information or answer any 
questions you may have. Please do not make any assumptions about the requirements or features of the Loadara API without first asking me for 
clarification. I want to ensure that the Loadara API is designed to meet all of the requirements and features that I have outlined above. Thank you 
for your help with this project.

Field description to use for setting up database, backend API, and frontend web interface.

All virtual servers, pools, servers, monitors, acls, certificates, scripts, maps, tables can be defined as separate, independent resources in the 
database and can be referenced by other resources.

Note: the list below is not definitive for all fields, but an illustration of the types of fields that should be included for each resource and how 
they should be related to each other.

Example Virtual Servers fields:
Name:
Description:
IP: (Virtual IPs that don't match a local interface are added to the keepalived configuration as a virtual_ipaddress)
Port:
Mode: TCP (HAProxy Virtual Server Configuration), UDP (Keepalived Virtual Server Configuration), HTTP (HAProxy Virtual Server Configuration), HTTPS 
Timeouts: (Implement HAProxy frontend server, client, connect, and other timeouts)
Custom Options: (contain HAProxy frontend configuration options such specific for HTTP, HTTPS, or TCP frontend types. i.e cookie <options>, fullconn, source, option forwardfor, http-request add-header, etc.)
Health monitor: (Display Name of monitor, but tied to ID from monitors table. http-check, http-check , tcp-check, etc.)
SSL Certificate: (If HTTPS is selected as mode. Display SSL Cert Name. Tied to ID from SSL Certs table)
ACLs: (Display Name of ACL, but tied to IDs from ACLs table. Field is array with multiple ACLs that can be selected.)
Pool: (Display Name of pool, but tied to ID from pools table)

Pools Fields:
Name:
Description:
Health Monitor: (Display Name of monitor, but tied to ID from monitors table. http-check, http-check , tcp-check, etc.)
Load Balancing Algorithm: (roundrobin, leastconn, hash(req.cookie('cookie_name'), sticky, rdp_cookie, etc. Ensure dynamic parameter field is displayed if parameter is required for load balancing method ))
Traffic Table: (Display Name of "Traffic Table", but tied to ID from "Traffic Tables" table. Traffic tables are Haproxy stick-table definitions. If clustering is enabled then reference peers name [default is loadara_cluster] in stick-table definition. )
Traffic Tables Options: (If Traffic Table is selected, then display the traffic table options that can be configured for the stick-table such as stick on, stick match, etc. ACLs can also reference stick-tables with fetchers instead of using stick-on or match) 
ACLs: (Display Name of ACL, but tied to IDs from ACLs table. Field is array with multiple ACLs that can be selected.)
Custom Options: (Allow user to add multiple lines of custom HAProxy configuration i.e. timeouts, and other backend options - http-reuse, http-send-name-header,)
Servers: (Array of server IDs that are selected from servers table)

Note: There should be options to add an existing or new server, or new or existing traffic table from the pool form in the UI. Display appropriate forms for creating new resources.

Servers Fields:
Name:
Description:
IP:
Port:
Weight:
Health Check: (Guided Field: Ensure server style check syntax. Options to be passed to config generator when specifying servers)
Custom Options: (Allow user to add any custom HAProxy server configuration i.e. timeouts, and other server options)

Health Monitors Fields:
Name:
Description:
Type: (TCP, HTTP, HTTPS, SMTP, etc. Check Haproxy documentation for all of the available check or monitor types.)
Custom Options: (add any custom options that are specific to the monitor type. i.e. send-state, expect HTTP 200, etc.)
Timeout:
Interval:


Certificates fields:
Name:
Description:
Certificate: (File Upload)
Key: (File Upload)
CA Certificate: (File Upload)

ACL Rules fields: (ACL Rules Wizard in Web UI providing drop downs of all options below and guided creation of ACL rules.)
Name:
Description:
Mode: (Valid values: http, https, tcp. UDP is handled by keepalived and does not allow ACLs & should be disabled. )
ACL: (Display Name of ACL, but tied to ID from ACLs table)
Condition: (Required field. Haproxy Fetchers that can be used as the condition for the ACL. Reference HAproxy fetchers for complete list)
Condition Parameters: (Optional field. If the selected condition requires parameters, then display the parameters that can be configured for the condition. Reference HAproxy fetchers for complete list)
Converter: (Optional field. Haproxy Converters that can be used to transform the output of the condition. Reference HAproxy converters for complete list)
Converter Parameters: (Optional field. If the selected converter requires parameters, then display the parameters that can be configured for the converter. Reference HAproxy converters for complete list)
Operator: (Optional field. Operators that can be used to compare the output of the fetcher or converter to the value. Reference HAproxy operators for complete list)
Operator Value: (Optional field. If the selected operator requires a value, then display the value that can be configured for the operator. Reference HAproxy operators for complete list)  
Action: (Required field. Actions that can be performed if the ACL rule matches. i.e use_backend <pool> if <ACL>, use_server <server> if <ACL>, etc. Reference HAproxy actions for complete list)
Traffic Table: (Optional field. Display name of Traffic Table, but tied to Traffic Table ID for lookup in db. It's used only in a HA Proxy Stick-table rule ACL definition. Reference HAproxy fetchers that utilize stick-tables.)
Traffic Maps: (Optional field. Display name of Traffic Map, but tied to Traffic Map ID for lookup in db. It's used only in a HA Proxy Map rule ACL definition. Reference HAproxy fetchers that utilize maps.)

Traffic Scripts fields: (To be implemented Later)
Name:
Description:
Script: (Code Editor for user to write custom HAProxy configuration or lua scripts)
Type: (Configuration, Lua Script)

Traffic Tables fields: 
Name:
Description:
Table Options: (HAProxy stick-table options i.e. size, expire, etc. Reference HAproxy stick-table options for complete list)
Size:
Expire:
Store:
Type:
Store Options:

Traffic Maps fields:
Name: (Traffic maps are files on the local disk that HAProxy can use to lookup values for use in ACL rules to route traffic or perform other actions.)
Description:
Map Data: (Key-value pairs that can be added to the map. Key and Value should be displayed in the form so that users can add multiple key-value pairs to the file one per line.)

Users fields:
Username:
Name:
Email:
Password:
Role: (Optional: Tied to role ID from roles table)
Group: (Optional: Tied to group ID from user groups table)

User Groups fields:
Name:
Description:
Users: (Array of user IDs that are selected from users table)
Roles: (Array of role IDs that are selected from roles table)

Roles fields:
Name:
Description:
Permissions: (Array of permissions that are tied to permission IDs from permissions table)

Permissions fields: (Backend table entries pre-populated with all possible endpoints and methods. No user created permissions. Users can select permissions in roles and assign to users or groups)
Name:
Description:
Endpoint:
Permission:

Cluster fields: (When Clustering is enabled in the system settings it configures keepalived on each node as part of a failover group along with optional floating ip. Peer Table is configured in Global section of Haproxy Config with each node ip & port)
Default Cluster name is loadara_cluster to be used in keepalived vrrp configuration and haproxy peers configuration.
Enabled:
Floating IP: (virtual IP address configured in keepalived configuration)
Nodes: (Array of node IDs that are selected from nodes table)

Cluster Nodes fields:
Name:
Description:
IP:
Port: (Provide default value as its configured)
Role: (Primary, Standby - This sets which node should be the primary active load balancer. Standby is the default role for all nodes. Primary role can only be assigned to one node.)

Note - Clusters fields and cluster nodes fields should be part of the same web interface page.

System Settings Fields:
Hostname: (Used to configure hostname in keepalived and haproxy configuration)
Network Interfaces: (Shows 2 fields of available and added network interfaces. User can add multiple interfaces to the load balancer configuration to support load balancing traffic. Added interfaces are used to configure keepalived unicast_peer and haproxy peers. Will add on setting up bridged/aggregate interfaces in the future. For now the User can configure this on the OS if it's needed)
Routes: (Users can add multiple additional custom routes that will be added to the linux routing table.)
